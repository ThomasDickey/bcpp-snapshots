# $Id: makefile.in,v 6.19 2010/06/27 22:09:07 tom Exp $
# Makefile-template for 'conflict'

THIS		= conflict
RELEASE		= t20100627

#### Start of system configuration section. ####

SYSTEM		= @SYSTEM@
srcdir		= @srcdir@
VPATH  		= @srcdir@

CC		= @CC@
LINK		= $(CC)
INSTALL		= @INSTALL@
INSTALL_PROGRAM	= @INSTALL_PROGRAM@
INSTALL_DATA	= @INSTALL_DATA@

CTAGS		= @CTAGS@
ETAGS		= @ETAGS@
LINT		= @LINT@

LIBS		= @LIBS@
CFLAGS		= @CFLAGS@ @EXTRA_CFLAGS@
LDFLAGS		= @LDFLAGS@

prefix		= @prefix@
exec_prefix	= @exec_prefix@

bindir		= @bindir@
mandir		= @mandir@/man1
manext		= 1

x		= @EXEEXT@
o		= .@OBJEXT@

#### End of system configuration section. ####

SHELL		= /bin/sh

CPPFLAGS	= -I. -I$(srcdir) -DHAVE_CONFIG_H -DRELEASE=\"$(RELEASE)\" @CPPFLAGS@ @EXTRA_CPPFLAGS@


SRC =	CHANGES COPYING README \
	$(THIS).c $(THIS).h $(THIS).1 \
	txtalloc.c unix.c msdos.c os2.c \
	aclocal.m4 config_h.in install-sh mkdirs.sh makefile.in configure.in \
	config.guess config.sub \
	run_test.sh

OBJ = $(THIS)$o $(SYSTEM)$o txtalloc$o

DISTFILES = MANIFEST configure $(SRC)

PROG	= $(THIS)$x

all:	$(PROG)

.c$o:
	@RULE_CC@
	@ECHO_CC@$(CC) -c $(CPPFLAGS) $(CFLAGS) $<

$(PROG): $(OBJ)
	@ECHO_LD@$(LINK) $(CFLAGS) $(LDFLAGS) -o $(PROG) $(OBJ) $(LIBS)

$(OBJ) : conflict.h

install: all installdirs
	$(INSTALL_PROGRAM) $(PROG) $(DESTDIR)$(bindir)/$(PROG)
	$(INSTALL_DATA) $(srcdir)/$(THIS).1 $(DESTDIR)$(mandir)/$(THIS).$(manext)

installdirs:
	$(SHELL) ${srcdir}/mkdirs.sh $(DESTDIR)$(bindir) $(DESTDIR)$(mandir)

uninstall:
	rm -f $(DESTDIR)$(bindir)/$(PROG) $(DESTDIR)$(mandir)/$(THIS).$(manext)

mostlyclean:
	rm -f *$o core *~ *.BAK

clean: mostlyclean
	rm -f $(PROG)

distclean: clean
	rm -f makefile config.log config.cache config.status config.h
	rm -f tags TAGS # don't remove configure!

realclean: distclean
	@-

lint :
	$(LINT) $(CPPFLAGS) $(OBJ:o=c)

tags :
	$(CTAGS) $(THIS).c $(HDRS)

@MAKE_UPPER_TAGS@TAGS:
@MAKE_UPPER_TAGS@	$(ETAGS) $(THIS).c $(HDRS)

# I keep my sources in RCS, and assign a symbolic release to the current patch
# level.  The 'manifest' script knows how to build a list of files for a given
# revision.
MANIFEST:
	manifest -r$(RELEASE) \
		$(THIS).man testing/case*.dcl testing/case*.bat

dist:	makefile $(DISTFILES)
	echo $(THIS)-$(RELEASE) > .fname
	rm -rf `cat .fname`
	mkdir `cat .fname`
	for file in $(DISTFILES); do \
	  ln $(srcdir)/$$file `cat .fname` \
	    || { echo copying $$file instead; cp -p $$file `cat .fname`; }; \
	done
	tar -cf - `cat .fname` | gzip >`cat .fname`.tgz
	rm -rf `cat .fname` .fname

shar:	$(DISTFILES)
	shar -a -m -M -L50 -n$(THIS) -oPart $(DISTFILES)

$(THIS)$o:	config.h

check: $(PROG)
	sh $(srcdir)/run_test.sh	
